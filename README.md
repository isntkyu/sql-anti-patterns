# sql-anti-patterns
SQL AntiPatterns - Bill Karwin


![스크린샷 2023-10-22 오후 11 23 50](https://github.com/isntkyu/sql-anti-patterns/assets/56504493/51ca2218-b0b0-4ef2-99b7-adf4eb99e831)


---

# 무단횡단

일대다 관계 테이블의 요구사항이 다대다로 바뀐 상황.
한 컬럼에 쉼표로 이어진 다중 값 속성을 사용한다.
> 건너기만 하면 된다는 무단횡단에 비유

이러면 안되는 이유
- 조회시 패턴매칭해야함 > 인덱스 안탐
- 집계함수 못씀
- 정렬도 안됨
- 수정이 복잡함
- 유효성 검증이 안됨
- 구분자를 절대 쓰이지 않을 문자로 해야함
- 길이(항목수) 제한이 있다

```
결론
중간 테이블을 써야함
```

--- 
# 순진한트리  

데이터의 재귀적 관계

계층 구조를 만들때는 모든자식을 한번에 조회할수있는지 체크해야한다

1. parent_id 컬럼을 추가하는 방법 (인접목록)
	1. 조인의 개수만큼의 뎁스의자식만 가져올 수 있다 (동적으로 조인추가가 안되니깐)
	2. select 컬럼이 늘어나야해서 집계함수 사용이 어렵다
	3. 노드 삭제가 어렵다(복잡 위험)

2. 재귀적 쿼리도 있음.

## 해법

### 경로열거

Path 라는 컬럼을 추가해서 경로를 입력 (디렉토리 구조 처럼)
하지만 검증 비용이 많고  애플리케이션 레벨에서 만들어지기 떄문에 의존적이며
무단횡단 < 의 단점을 많이 공유한다.

### 중첩집합

nsleft, nsright 컬럼추가
사용법: DFS 로 탐색하며 내려가면서nsleft값을 입력하고 다시 올라오면서 nsright 값을 입력한다.

강점: 부모노드를 삭제해도 할아버지 노드와 자식 노드가 새롭게 부모자식으로 이어진다

그 외에는 모든 사용법이 너무 복잡하다

### 클로저테이블

새로이 테이블을 생성한다. 
이 테이블은 조상 자손 관계 또는 경로까지 담고있다.

---

# 아이디가 필요해

pk 에 대한 이야기이다.  
모든 pk 를 가상키 id 로 이름짓게 되면,  
외래키 조인 시 USING 쿼리를 사용 불가함 (같은 컬럼명이면 유용한데, 외래키로 id 를 넣을 수 없다. 그 테이블에도 id가 있어서)

다대다 교차테이블에서 가상키 Pk 를 따로잡는 것도 안티패턴이라함 (자주 이렇게 사용하고있었다.)

꼭 가상키pk 가 필요하지 않다는 걸 설명하고 있다.  
자연키가 좋다고 하는데, 자연키가 인덱싱이 어려운 값일 경우엔 가상키가 좋다고 한다.

## 해법

### 상황에 맞추기

auto_increment랑 pk 는 독립적인 개념인 것 명확히 하기.  
인덱스를 지원하기만 하면 어느것이 pk 일 수 있다.

의미 있는 컬럼명을 짓자.

### 자연키와 복합키 포용

관례에 얽매이지 말자.

유일하고 not null이며 행 식별이 가능하다면 통념때문에 가상키를 고집하지 않아도 된다.  

다대다 교차테이블에서 양쪽의 pk 외래키를 복합pk로 하면 장점은 ?!  
조인을 안해도된다.  근데 fk 도 복합키가 다 들어가야함.

복잡한 것 같다.

---

# 키가 없는 엔트리

fk에 대한 이야기이다.
참조 정합성은 중요하지만 개발단계에서의 불편함이 있긴 하다.

최근에는 fk를 잘 안쓰고 있었다.  
정합성을 db에러가 아닌 애플리케이션 단에서 select 후에 예외를 뱉는 식이 가독성과 에러처리가 좋아보여서다.

개발단계에서의 테스트의 용이성이나  
긴급 db직접 수정으로 장애를 대응하는 경우도 있긴 하다는걸 부정할 순 없겠다..

어차피 정합성을 맞추기 위해서 orm이나 애플리케이션 단에서의 로직. 혹은 클라우드 단의 로그 및 히스토리관리 서비스 등을 이용하기 용이하다는 생각이었다.

더군다나 책에서의 성능에대한 반박으로써   
insert delete update 시에 select가 없어도 된다는 말은 기억했다.

---

# 엔터티-속성-값

EAV, 오픈스키마, 스키마리스, 이름-값쌍  
가변 속성에 대해 속성이름과 값을 행마다 갖는 테이블을 따로 만드는 것.

- 사용하기 어려움.
- 필수 속성 사용 불가
- sql 데이터타입 사용 불가
- 참조정합성 강제 불가
- 속성 이름 강제 불가

차라리 NoSQL을 쓰지

## 해법: 서브타입 모델링

단일 테이블 상속: 그냥 하나의 테이블에 전부 속성을 넣는 것. 속성간 관계에 대한 메타데이터가 없다.
구체 테이블 상속 
클래스 테이블 상속: 서브타입에 대한 테이블 만들기 join으로 하나의 테이블처럼 쓸 수 있다.
반구조적 데이터: 한 컬럼에 모든 동적 속성 넣기 json 등으로

---

# 다형성 연관

예를 들어 댓글 이라는 테이블이  
여러테이블과 다대일 관계를 갖을 때  
어떤 테이블과 연관있는지 부모테이블 이름을 넣는 컬럼을 만든다

fk를 사용할 수 없고 EAV 처럼 무한한 유연성을 갖는다.

## 해법

### 역참조

각각 교차테이블을 만든다. 일대다 이기 때문에 자식쪽 fk에 unique를 잡기.

### 공통 슈퍼테이블 만들기

두 부모와 자식 모두 같이 참조하는 슈퍼테이블을 만든다. 
최상위 추상화 부모테이블을 만드는 것  
두 부모의 공통 슈퍼테이블을 놓고 자식도 이 태이블을 참조한다

---

# 다중 값 속성

몰랐던 건데 where-in 구절을 사용할 때
where col in ( var ) 만 되는 게 아니라 where var in (col, col2 ..) 도 된다.

---

# 메타데이터 트리블

안티패턴예시: 테이블이름이나 컬럼명에 년도를 붙이는 것  
- 테이블의 컬럼마다 CHECK 제약을 걸어야 할 수 있음
- 테이블간 데이터 이동 혹은 수정 어려움, pk 유일성 해침.
- 조회시 union 필요
- 하위테이블에서 Fk 사용못함(논리적인 부모가 여러개)
- 반대로 상위테이블에서 조인 어려움(논리적 자식이 여러개)
- 컬럼의 경우도 마찬가지임

> 합당한 경우: 오래된 데이터를 조회할 일이 없는 경우.

## 해법: 파티션과 정규화

파티셔닝  
수직파티셔닝: blob, text 등의 데이터를 수직파티셔닝하면 좋음.

데이터가 메타데이터를 낳지 않기.

---

# 반올림 오류

float 데이터유형을 사용하지말자.  
실제 디비 저장된 숫자와 다르게 select시에 보정될 수 있다. (ieee754)

숫자의 범위가 아주 클때는 사용하면 좋다.

numeric, decimal 타입을 쓰자.

---

# 31가지 맛

칼럼을 특정 값(enum)으로 제한하기(check)  
check, enum 제약을 사용하면 변경이 몹시 어려움.

사용이 합당할 때: left/right, on/off 처럼 상호배타적이어서 변경이 일으나지 않을 경우. (isOn: boolean이 더 편할 수도)

## 해법: 데이터로 값을 지정하기

색인 테이블 만들기.


---

# 유령 파일

데이터베이스에는 경로만 저장하고 파일시스템에 파일저장하는 것에 대한 문제

- 컬럼삭제와 파일삭제를 자동으로 연관시킬 방법이 없다.
- 파일시스템은 트랜잭션을 타지 못한다.
- DB 와 함께 백업되지 못한다.
- SQL로 파일 권한을 통제하지 못한다.
- 데이터 정합성을 지키지 못한다.(파일 이동,수정시)

합당한경우: 배치성 이미지 편집이 필요할경우, (or 용량)

## 해법: BLOB 타입

or S3 쓰기./

---

# 인덱스 샷건

성능최적화  
복합인덱스에서는 순서가 중요하다. 검색, 조인, 정렬 순서에 맞게 배열한다.

선택도(selectivity) = count distinct COLUMN / count COLUMN

## 해법: 인덱스를 MENTOR하라

Measure, Explain, Nominate, Test, Optimize, Rebuild

> 커버링인덱스: 인덱스에 추가속성 포함시켜서 실제 대응되는 행을 찾지 않아도 되게 하는 기법

오토매틱 어드바이저 사용.

### 인덱스를 캐시에 미리 로딩하기: Mysql load index into cache; 등등

인덱스 재구성 정비 도구 사용.

---

# 모르는 것에 대란 두려움

null 과의 비교는 어떻게 햐도 참이 될 수 없다.  
다음 모두 null 인 값이 select 되지 않는다.  
- where col = 1
- where not (col = 1)
- where col = null
- where col <> null
- where null = null

참이 되는 경우
- where null or true

---

# 애매한 그룹

group by 절과 집계함수 사용시에 다른 컬럼을 select 하지않기( 단일 값 규칙 위반 )


집계함수 없는 groupby와 distinct의 성능차이는.거의 없다. 취향차

mysql은 단일.값 규칙 위반한 컬럼을 (물리적으로) 첫번째 행을 보여준다

유일한 값의 조합을 그룹핑하면 오류는 없음.

### 해법중 하나: group_concat

---

# 임의의 선택

임의정렬 문제 order by rand() 은 인덱스를 활용 못해 성능이 낮다.

해법으로는 max pk나 count rows 를 해서 랜덤 pk나 offset 을 사용한다.

---

# 가난한 자의 검색 엔진

정규식 검색이나 like 앞뒤와일드카드 검색의 성능문제


### 해법

#### Mysql myisam  
fulltext index  
select where match() - against 

#### oracle
context  where contains
ctxcat

#### PostgreSql
tsvector 타입 컬럼.

---

# 스파게티 코드

여러테이블과 복잡한 집계함수에서  
곱집합을 기준으로 집계되어 값이 전부 틀리는 현상

쿼리를 나누자. 유니온을 쓰자

---

# 암묵적 칼럼

select 와일드카드 (*) 는 애플리케이션 쿼리에서는 사용하지 말고 명시적으로 칼럼을 적자.

---

# 읽을 수 있는 패스워드

패스워드 평문 저장에 대한 이야기

아이디 비번을 검사하는 쿼리를 날릴 때  
where 절에 id 조건과 패스워드 조건을 같이 넣으면 안되는 이유는?  

아이디가 틀릴 때와 패스워드가 틀릴 때를 구분 못한다.

## 해법

해시

패스워드 재설정시 임시패스워드발급 (애플리케이션 단에서 만료가 있는 임시패스워드)

만료기간이 짧은 재설정페이지를 메일로 제공

---

## SQL 인젝션

쿼리가 파싱되기 전 (동적쿼리생성) 시에 인젝션 위험이 있다.

쿼리파라미터 사용

